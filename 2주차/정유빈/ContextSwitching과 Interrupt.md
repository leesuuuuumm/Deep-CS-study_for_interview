<h1> Interrupt </h1>

- 예상치 못하거나 외부에섭 발생한 이벤트로 인해 프로세스를 잠시 중단하는 것을 인터럽트라고 한다.
- 컴퓨터 시스템에서 발생하는 예외적인 사건을 신속히처리하기 위한 기법
- 인터럽트가 발생하면 해당 인터럽트 처리 루틴을 먼저 수행후 원래 프로그램으로 되돌아온다.

<h1> Context Switcing </h1>

- 문맥 교환이란 스케쥴링에 따라 실행중인 프로세스를 교체할 때 교체되는 프로세스의 상태를 기억시켜 두고 새로운 프로세스의 이전 실행 상태를 재복구하여 처리기에 넘겨주는 일련의 작업을 의미한다.
- 실행하던 프로그램이 중단되고 인터럽트 처리를 수행하기 전엡 ㅏㄹ생한다.
- 여러 프로세스가 하나의 CPU를 공유한다는 것을 알 수 있다.

<H1> 과정 </H1>

- 인터럽트가 발생하면, 프로세스를 종료하고 다음 프로세스를 수행
- 이 때 종료될 프로세스의 context를 PCB에 업데이트하고, 실행할 다음 프로세스의 context를 메모리에 올려서 cpu가 실행할 수 있도록 한다.
- 하지만 Context Switcing일 때, 해당 cpu는 아무 일을 할 수 없어서 오버헨드가 발생한다. -> 성능 떨어져서 적당히 해야한다.

<h1> Context saving to PCB </h1>

- 인터럽트가 발생하여 프로세스를 중단할 때, 진행중이던 작업 정보를 잃으면 위에서의 멀티 태스킹을 정상적으로 수행할 수 없다.
- 그 정보를 Context라 한다.
- 이러한 Context를 저장함으로써 작업 상태를 유지하고, 되돌아갈 수 있다.

- 일단 작업중이던 프로세스의 (1) 코드,데이터, 스택, pcb와 같은정보가 있겠고,
- (2) CPU에서의 작업 내용에 관한 정보가 있을 텐데,

- (1)과 같은 경우는 <b> 메모리 내에 존재함 </b> 으로 별도로 저장을 할 필요가 없다.
- 메모리 용량이 모자라도 디스크를 이용한 swap으로 처리한다.

- (2)의 경우인 CPU register context, 즉 CPU가 레지스터에서 작업중이던 내용은 CPU에 존재하는데, 이 CPU를 다른 프로세스에게 양보하거나 해야하므로 이를 pcb에 저장한다.

<h1> Interrupt handling </h1>

- 이후, Interrupt handler라는 처리기로 인터럽트가 발생한 원인 및 장소를 파악하고, 이를 처리하기 위해 어떤 Service Routine을 호출할 것인지를 결정한다.
- 즉, Interrupt Vector 테이블을 참조하여 호출할 ISR(인터럽트 서비스 루틴) 주소 값을 얻는다.
- Interrupt Service Rountine(ISR)이라는 인터럽트 처리 동작을 수행하게 된다.


<H1> 참고 </H1>

<h4> ** 인터럽트란? </h4>

- 인터럽트(Interrupt)란, "방해하다"라는 듯으로, 여러 가지 일을 처리해야만 하고 동시에 처리할 수 없는 일들을 순서적으로 하나씩 처리해야 한다.
- 그러나, 지금 하고 있는 일보다 긴급한 일이 발생하면 그 일을 먼저 처리해주고 나서 하던 일을 계속하게 되는 것이다.
- 이러한 일을 인터럽트라 한다.
- 일의 경중에 따라 인터럽트 중요도(Priority)가 결정되고, 현재하고 있는 일과 비교해서 우선순위 처리를 판단하게 된다.
- 요기서 인터럽트 때의 할 일이 인터럽트 서비스 루틴(ISR: Interrupt Sevice Routine)이다.
- 실질적으로 임베디드 시스템에서 <b> 인터럽트 활용이 마이크로컨트롤러의 수행능력을 극대화하는데 꼭 필요한 기능이며, 특히 실시간을 절실하게 요청하는 경우에 매우 큰 도움을 준다. </b>

![image](https://github.com/youbeen2798/Deep-CS-study_for_interview/assets/62228401/08b37e4c-ec1e-4236-be16-5179a1c9baca)


<h4> 폴링과 인터럽트 & 인터럽트 서비스 루틴 </h4>

- <b> 인터럽트가 발생하면 현재 수행중인 프로그램을 멈추고 상태 레지스터와 PC(Program Counter) 등을 스택에 잠시 저장한 후 인터럽트 서비스 루틴으로 점프한다.
- 잠시 저장하는 이유는 인터럽트의 서비스 루틴이 끝나고 나서 <b> 다시 원래의 해당 작업으로 돌아와야 하기 때문 </b> 이다.
- 아래는 인터럽트 서비스 루틴의 실행과정을 나타낸 순서이다.

  ![image](https://github.com/youbeen2798/Deep-CS-study_for_interview/assets/62228401/f18a5a4f-f645-4390-909d-ad28522b7922)


<h4> 마이로컨트롤러의 외부 입출력 방법 </h4>

- 마이크로 컨트롤러에서 입력을 받아들이는 방법은 2가지가 있다.
- <u> 폴링(polling) 방식 </u> : 사용자가 명령어를 사용하여 입력 핀의 값을 계속 읽어서 변화를 알아내는 방식
- <u> 인터럽트(interrupt) 방식 </u> : MCU 자체가 하드웨어적으로 그 변화를 체크하여 변화시에만 일정한 동작을 하는 방식

- 폴링방식은 하드웨어 지원 없이도 언제든지 가능하다.
- 반면에 인터럽트 방식은 하드웨어적으로 지원되는 몇 개의 입력 또는 값의 변화에만 대응처리가 가능하다는 제약이 있으나, 폴링에 비해 신속하게 대응할 수 있다.
- 특히 실시간 대응이 필요한 경우에는 필수적인 기능이다.
- <b> 인터럽트는 발생 시기를 예측하기 힘든 경우에 마이크로컨트롤러가 가장 빠르게 대응할 수 있는 방법이고, 비교적 저속으로 동작하는 주변장치의 요청에 고속으로 요청하는 마이컴이 효율적으로 대처하는 중요 수단이다. </b>
