<h1> Interrupt </h1>

- 예상치 못하거나 외부에섭 발생한 이벤트로 인해 프로세스를 잠시 중단하는 것을 인터럽트라고 한다.
- 컴퓨터 시스템에서 발생하는 예외적인 사건을 신속히처리하기 위한 기법
- 인터럽트가 발생하면 해당 인터럽트 처리 루틴을 먼저 수행후 원래 프로그램으로 되돌아온다.

<h1> Context Switcing </h1>

- 문맥 교환이란 스케쥴링에 따라 실행중인 프로세스를 교체할 때 교체되는 프로세스의 상태를 기억시켜 두고 새로운 프로세스의 이전 실행 상태를 재복구하여 처리기에 넘겨주는 일련의 작업을 의미한다.
- 실행하던 프로그램이 중단되고 인터럽트 처리를 수행하기 전에 발생한다.
- 여러 프로세스가 하나의 CPU를 공유한다는 것을 알 수 있다.


<h1> 컨텍스트 스위치 </h1>

- 멀티태스킹 컨텍스트에서, 한 태스크에 대해 시스템 상태를 저장하여 작업을 일시 중지하고 다른 태스크가 재개되도록 하는 프로세스를 말한다.
- 컴퓨팅에서 컨텍스트 스위치는 프로세스 또는 스레드 상태를 저장하여 나중에 같은 지점에서 복원하고 실행을 재개하는 과정이다.
- 이를 통해 여러 프로세스가 하나의 CPU를 공유할 수 있으며, 멀티태스킹 운영체제의 필수적인 기능이다.
- 또한 컨텍스트 스위치는 작업이 디스크 스토리지에 액세스해야 하는 경우와 같이 인터럽트의 결과로 발생하여 다른 작업에 대 CPU 시간을 확보할 수 있다.
- 일부 운영체제에서는 사용자 모드와 커널 모드 작업을 이동하기 위해 컨텍스트 스위치가 필요하다.
- 컨텍스트 전환 스위치는 수행 중인 스위치의 특성에 따라 이 효과의 크기가 달라지지만 시스템 성능에 부정적 영향을 미칠 수 있다.
<H1> 과정 </H1>

- 인터럽트가 발생하면, 프로세스를 종료하고 다음 프로세스를 수행
- 이 때 종료될 프로세스의 context를 PCB에 업데이트하고, 실행할 다음 프로세스의 context를 메모리에 올려서 cpu가 실행할 수 있도록 한다.
- 하지만 Context Switcing일 때, 해당 cpu는 아무 일을 할 수 없어서 오버헨드가 발생한다. -> 성능 떨어져서 적당히 해야한다.

<h1> Context saving to PCB </h1>

- 인터럽트가 발생하여 프로세스를 중단할 때, 진행중이던 작업 정보를 잃으면 위에서의 멀티 태스킹을 정상적으로 수행할 수 없다.
- 그 정보를 Context라 한다.
- 이러한 Context를 저장함으로써 작업 상태를 유지하고, 되돌아갈 수 있다.

- 일단 작업중이던 프로세스의 (1) 코드,데이터, 스택, pcb와 같은정보가 있겠고,
- (2) CPU에서의 작업 내용에 관한 정보가 있을 텐데,

- (1)과 같은 경우는 <b> 메모리 내에 존재함 </b> 으로 별도로 저장을 할 필요가 없다.
- 메모리 용량이 모자라도 디스크를 이용한 swap으로 처리한다.

- (2)의 경우인 CPU register context, 즉 CPU가 레지스터에서 작업중이던 내용은 CPU에 존재하는데, 이 CPU를 다른 프로세스에게 양보하거나 해야하므로 이를 pcb에 저장한다.

<h1> Interrupt handling </h1>

- 이후, Interrupt handler라는 처리기로 인터럽트가 발생한 원인 및 장소를 파악하고, 이를 처리하기 위해 어떤 Service Routine을 호출할 것인지를 결정한다.
- 즉, Interrupt Vector 테이블을 참조하여 호출할 ISR(인터럽트 서비스 루틴) 주소 값을 얻는다.
- Interrupt Service Rountine(ISR)이라는 인터럽트 처리 동작을 수행하게 된다.


<H1> 참고 </H1>

<h4> ** 인터럽트란? </h4>

- 인터럽트(Interrupt)란, "방해하다"라는 듯으로, 여러 가지 일을 처리해야만 하고 동시에 처리할 수 없는 일들을 순서적으로 하나씩 처리해야 한다.
- 그러나, 지금 하고 있는 일보다 긴급한 일이 발생하면 그 일을 먼저 처리해주고 나서 하던 일을 계속하게 되는 것이다.
- 이러한 일을 인터럽트라 한다.
- 일의 경중에 따라 인터럽트 중요도(Priority)가 결정되고, 현재하고 있는 일과 비교해서 우선순위 처리를 판단하게 된다.
- 요기서 인터럽트 때의 할 일이 인터럽트 서비스 루틴(ISR: Interrupt Sevice Routine)이다.
- 실질적으로 임베디드 시스템에서 <b> 인터럽트 활용이 마이크로컨트롤러의 수행능력을 극대화하는데 꼭 필요한 기능이며, 특히 실시간을 절실하게 요청하는 경우에 매우 큰 도움을 준다. </b>

![image](https://github.com/youbeen2798/Deep-CS-study_for_interview/assets/62228401/08b37e4c-ec1e-4236-be16-5179a1c9baca)


<h4> 폴링과 인터럽트 & 인터럽트 서비스 루틴 </h4>

- <b> 인터럽트가 발생하면 현재 수행중인 프로그램을 멈추고 상태 레지스터와 PC(Program Counter) 등을 스택에 잠시 저장한 후 인터럽트 서비스 루틴으로 점프</b>한다.
- 잠시 저장하는 이유는 인터럽트의 서비스 루틴이 끝나고 나서 <b> 다시 원래의 해당 작업으로 돌아와야 하기 때문 </b> 이다.
- 아래는 인터럽트 서비스 루틴의 실행과정을 나타낸 순서이다.

  ![image](https://github.com/youbeen2798/Deep-CS-study_for_interview/assets/62228401/f18a5a4f-f645-4390-909d-ad28522b7922)


<h4> 마이로컨트롤러의 외부 입출력 방법 </h4>

- 마이크로 컨트롤러에서 입력을 받아들이는 방법은 2가지가 있다.
- <u> 폴링(polling) 방식 </u> : 사용자가 명령어를 사용하여 입력 핀의 값을 계속 읽어서 변화를 알아내는 방식
- <u> 인터럽트(interrupt) 방식 </u> : MCU 자체가 하드웨어적으로 그 변화를 체크하여 변화시에만 일정한 동작을 하는 방식

- 폴링방식은 하드웨어 지원 없이도 언제든지 가능하다.
- 반면에 인터럽트 방식은 하드웨어적으로 지원되는 몇 개의 입력 또는 값의 변화에만 대응처리가 가능하다는 제약이 있으나, 폴링에 비해 신속하게 대응할 수 있다.
- 특히 실시간 대응이 필요한 경우에는 필수적인 기능이다.
- <b> 인터럽트는 발생 시기를 예측하기 힘든 경우에 마이크로컨트롤러가 가장 빠르게 대응할 수 있는 방법이고, 비교적 저속으로 동작하는 주변장치의 요청에 고속으로 요청하는 마이컴이 효율적으로 대처하는 중요 수단이다. </b>

<h4> 인터럽트 구성 요소 </h4>

- 인터럽트는 3가지의 구성 요소로 이루어진다.

- <u> 발생원(Source) </u> : 누가 인터럽트를 요청했는가?
- <u> 우선순위(Priorty) </u> : 2개 이상의 요청시에 누구를 먼저 서비스할까? (중요도)
- <u> 인터럽트 백터(Interrupt Vector) </u> : 서비스 루틴의 시작 번지는 어디인가?

- <b> 인터럽트 백터는인터럽트가 발생하였을 때 해야할 일이 무엇인가를 정해놓은 바로 인터럽트 서비스 루틴(ISR)의 시작주소 </b>이다.
- 아래의 사진은 인터럽트 백터 테이블을 참조하는 과정의 그림이다.

  ![image](https://github.com/youbeen2798/Deep-CS-study_for_interview/assets/62228401/bd639ab4-b407-48fb-a396-7b98f327c43f)

<h4> ** 인터럽트 종류 </h4>

- 인터럽트의 종류는 발생 원인이 존재하는 곳에 따라 내부(Internal)과 외부(External)로 나누고, 차단 가능성에 따라 차단 가능(Maskable) 인터럽트와 차단 불가(Non Maskable) 인터럽트로 나누며, 인터럽트 발생 원인을 확인하는 방법에 따라 조사(Polled)와 벡터(Vectored)형으로 나누어진다.

  1. 발생원인에 따른 인터럽트 분류

      - 내부 인터럽트는 프로그램 진행 과정에서 영(0)으로 나누는 등의 금지된(Protected) 메모리로서의 접근 시도 등에 따라 마이컴 내부에서 발생하는 인터럽트이며, 외부(External) 인터럽트는 입출력 장치의 작업 종료, 타이머의 오버플로우(Overflow), 외부장치의 통신 요청 등 외부 장치에 의해 발생하는 인터럽트이다.
      - 일반적으로 인터럽트라고 하면 외부 인터럽트를 의미한다.
  2. 차단 가능성에 의한 인터럽트 분류

       - 상황에 따라 응답의 방법에 따라 요청된 인터럽트에 의해, <b> 항상 응답해야 하는 인터럽트를 마스크 불가능(NMI)인터럽트라고 하고, 그렇지 않은 경우를 마스크 가능(Maksable)인터럽트</b> 라 한다.
       - 전원 이상 등의 매우 중요
       - 
<h4> 인터럽트(Interrupt) </h4>

- I/O interrupt
    -> 마우스 클릭, 키보드 입력 등
- Clock interrupt
    -> CPU가 동작할 때 Clock 발생할 때
- Console interrupt
    -> 콘솔창에 입력할 때 발생
- Machine check interrupt
    -> 하드웨어 문제 발생시
- Inter-process interrupt
    -> 다른 프로세스에 의한 인터럽트

  
<h4> 인터럽트 백터 테이블 </h4>

- 인터럽트 백터 테이블이란, 여러 가지 인터럽트에 대해 해당 인터럽트 발생시 처리해야 할 루틴의 주소를 보관하고 있는 테이블을 의미한다.
- 인터럽트 백터 테이블은 주소공간에 4바이트씩 할당하여 256개가 존재하는데 이것을 인터럽트 벡터라고 한다.
- 인터럽트는 16진수 2자리로 이 벡터에서 해당 루틴의 번지가 기억된 순번을 지적하여 그 기능을 요청하면 그 곳에 기억된 번지로 분기하여 인터럽트를 수행하게 된다.

<h4> 인터러트 서비스 루틴 </h4>

- 인터럽트 서비스 루틴(Interrupt Service Routine)은 인터럽트 핸들러라고 하며, 실제 인터럽트를 처리하는 루틴으로 실행중이던 레지스터와 PC를 저장하여 실행중이던 CPU의 상태를 보존하고 인터럽트 처리가 끝나면 원래 상태로 복귀한다.
- 운영체제 코드 부분에는 각종 인터럽트 별로 처리해야 할 내용이 이미 프로그램에 되어있다.
