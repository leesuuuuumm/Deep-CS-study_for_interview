# FCFS (First-Come-Frist-Service)
![image](https://github.com/leesuuuuumm/Deep-CS-study_for_interview/assets/58407737/3d21150e-4d91-4719-bbfb-a150bc654d1d) </br>

### 선착순 알고리즘
### Non-preemptive scheduling
- 프로세스 하나가 Core를 할당 받으면 끝낼때까지 쓴다.

</br>

### 기준
- 도착 시간(선착순: 누가 Ready Queue에 먼저 들어왔나)

</br>

### 자원을 효율적으로 사용 가능 => High resource utilization
- 오는 순서대로 주기때문에 불필요한 스케줄링 오버해드가 없음
- CPU가 계속 일할 수 있다.

</br>

### Batch System(일괄처리 시스템)에 적합 / Interactive system에 부적합
- 오는 순서대로 빨리 처리해서 퍼포먼스 높이는게 효율적이기 때문에
- 대화형 시스템에는 즉시 응답이 불가능할 수 있기 때문에 부적합함

</br>

### 단점
- 긴 평균 응답시간 (response time)
  - 언제 결과(응답)을 돌려받을지 예측이 안된다.
- Convey effect
  - 하나의 수행시간이 긴 프로세스에 의해 다른 프로세스들이 긴 대기시간을 갖게 되는 현상 (대기시간>>>>>>> 실행시간)
  - 나는 2초면 끝나는데, 나보다 빨리 들어온 애는 100초가 걸린다. -> 그래서 나는 100초 기다려야한다. </br>
![image](https://github.com/leesuuuuumm/Deep-CS-study_for_interview/assets/58407737/c3f28ce1-7fa2-431e-977a-6617f87400c8) </br>

</br>



![image](https://github.com/leesuuuuumm/Deep-CS-study_for_interview/assets/58407737/de27a5fe-5533-444a-a7e4-4c98a9c19b52)

### Normalized Turn around Time(NTT) = Turn around time / Burst time 
- 내가 얼마나 기다렸는가 체감을 알려주는 지표
- 1보다 크고 크면 클수록 불공평하다고 느낌

</br>

# RR (Round-Robin)
![image](https://github.com/leesuuuuumm/Deep-CS-study_for_interview/assets/58407737/279bcaa5-e2cd-4820-a11e-4df46123ceae) </br>

- 제한시간이 지나면 맨 뒤로 가서 대기한다.

### Preemptive Scheduling 
- 돌아가면서 쓰자
  
</br>

### 기준
- 도착 시간(누가 Ready Queue에 먼저 들어왔나)
- 먼저 도착한 프로세스를 먼저 처리

</br>

### 자원 사용 제한 시간(time quantum)이 있음
- System parameter이 있다.
- 프로세스는 할당된 시간이 지나면 자원을 반납해야한다. (Time-runout)
- 특정 프로세스의 자원 독점(monopoly) 방지 -> 장점
- Context switch overhead가 크다. (할당된 시간마다 계속 돌려야하니깐) -> 단점

</br>

### 대화형, 시분할 시스템에 적합

</br>

### Time quantum이 성능을 결정하는 핵심 요소이다.
- if, 제한시간이 무한대로 크다면 - FCFS
- else, 제한시간이 0에 수렴한다면 - processor sharing 
  - 사용자는 모든 프로세스가 각각의 프로세서 위에서 실행되는 것처럼 느낌 (체감 속도 = 실제 프로세서 성능의 1/n)
  - High context switch overhead

</br>

### Time quantum = 2초
![image](https://github.com/leesuuuuumm/Deep-CS-study_for_interview/assets/58407737/c0258c47-e8ab-4907-a422-187d96c9fe1f)

</br>

### Time quantum = 3초
![image](https://github.com/leesuuuuumm/Deep-CS-study_for_interview/assets/58407737/592257f2-d638-4e63-8e92-106187a230d4)

</br>

### Time quantum = 4초 
![image](https://github.com/leesuuuuumm/Deep-CS-study_for_interview/assets/58407737/bbc62562-4f7e-4e1a-80e7-93029c032ac3)

### Time quantum에 따라 성능에 변화가 있다.

</br>

# SPN (Shortest-Process-Next)
- 짧은 애를 먼저 빼주자
![image](https://github.com/leesuuuuumm/Deep-CS-study_for_interview/assets/58407737/0d81d051-dba3-4d40-9806-1d679846ad75)

</br>

### Non-preemptive scheduling

</br>

### 기준
- 실행시간 (burst time 기준)
- Burst time이 가장 작은 프로세스를 먼저 처리한다.
  - SJF (Shortest Job First) Scheduling

</br>

### 장점
- 평균 대기시간(WT) 최소화
- 시스템 내 프로세스 수 최소화
  - 스케줄링 부하 감소, 메모리 절약 -> 시스템 효율 향상
- 많은 프로세스들에게 빠른 응답 시간 제공

</br>

### 단점
- Starvation(무한대기) 현상 발생 => 기아현상
  - BT가 긴 프로세스는 자원을 할당 받지 못 할 수 있음
      - 그래서 Aging 등으로 해결
- 정확한 실행시간을 알 수 없다. (Burst 시간을 알아야함)
  - 실행시간 예측 기법이 필요
 
### Aging 기법
- 시스템에서 특정 프로세스의 우선순위가 낮아 무한정 기다리는 경우를 방지하기 위해서 기다린 시간에 비례해서 일정 시간이 지나면 우선순위를 한 단계씩 높여주는 방법이다.
- 무한연기 or 기아상태를 예방하기 위한 기법
- Aging 기법을 도입해 HRN(HRRN) 기법으로 사용하는 것
- MLQ 기법에서 높은 우선순위를 먼저 처리하기 위해 Aing 기법을 도입해 MLFQ 기법으로 사용한다.
